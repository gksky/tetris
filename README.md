# tetris, assembler x86

# ИСТОРИЧЕСКИЙ ЛИКБЕЗ

В ВЦ АН СССР в середине 80-х работало немало людей, к которым впоследствии прочно и вне зависимости от их желания приклеился ярлык «легендарных личностей»: Евгений Веселов, Антон Чижов, Аркадий Борковский. Был среди них и Алексей Пажитнов — человек, которому судьба уготовила стать своеобразным зеркалом перемен, начавшихся с приходом к власти Михаила Горбачева.

Работая в ВЦ АН СССР, Пажитнов занимался проблемами искусственного интеллекта и распознавания речи. По его словам, в ту пору ему довольно часто приходилось писать игровые программы — неплохой инструментарий для тестирования нового оборудования. Больше всего Алексея привлекали игры-головоломки. Особенно нравилась ему классическая головоломка Pentomino Puzzle, в которой плоские фигуры двенадцати типов, состоящие из расположенных различным образом пяти квадратных элементов, нужно складывать в определенном порядке так, чтобы получить заданную форму.

Для начала Пажитнов написал программу, которая изменяла положение фигур, поворачивая их на 90 градусов относительно центра тяжести. В тот момент, как он вспоминал позже, он подумал, что в реальном времени это смотрелось бы потрясающе. Однако для того чтобы игра «шла» в реальном времени, требовались вычислительные ресурсы, которыми тогдашние микрокомпьютеры не обладали. И Пажитнов упростил головоломку, взяв фигуры, состоящие не из пяти, а из четырех квадратных элементов, что и определило название игры — «Тетрис» от греческого tetra («четыре»).

На дворе стоял 1985 г. На написание «Тетриса» на языке Pascal для «Электроники-60» у Пажитнова, как говорит он сам, ушло около двух недель. Коллеги Алексея по работе были в восторге от его программы, но сам он понимал, что расширить аудиторию игры можно лишь в том случае, если она будет портирована на IBM PC. В этом Пажитнову помог его приятель Вадим Герасимов, и через несколько недель вся компьютерная Москва уже знала, что такое «Тетрис».

# Структурное проектирование

После запуска EXE-файла монитор переключается в режим VGA 320x200 точек, 256 цветов. Этот режим наиболее удобен, т.к. информация о всех точках не выходит за пределы 64 kb видеопамяти и для описания цвета каждой точки необходим один байт. По середине экрана отображается стакан для фигурок, слева от него количество набранных очков, убранных линий и текущий уровень скорости. Справа от стакана располагаются подсказки по управлению игрой:
•	Клавиша «» осуществляет переворот фигурки,
•	Клавиша «» сдвигает фигурку влево,
•	Клавиша «» сдвигает фигурку вправо,
•	Клавиша «» осуществляет ускоренный сброс фигурки,
•	Клавиша «P» устанавливает/снимает паузу,
•	По клавише «Q» происходит выход из игры.

Прежде, чем отобразить первую фигурку нужно выбрать её из семи разных, для этого вызывается функция next_figure, которая с помощью псевдослучайных чисел определяет фигурку и присваивает переменной fig её адрес. Описание каждой фигурки занимает в памяти 5 байт: первые четыре для определения по двум координатам каждого квадратика относительно текущей точки (переменная cp) и пятый байт предназначен для цвета фигурки.

Затем вызывается функция put_figure, которая заполняет матрицу игрового поля цветом текущей фигурки по координатам относительно текущей точки, и вызывает функцию print_map, которая, в свою очередь, вызывает процедуру прорисовки квадратиков в стакане print_block.

В начале главного цикла программы происходит считывание символа с клавиатуры без ожидания и без эха на экран, если введённый символ равен ‘p’, то выполняются команды установки/снятия паузы. Если символ равен нулю, то выполняется проверка на расширенные символы ASCII, такие как клавиши стрелок; выполняется обработка команд, осуществляющих задержку падения фигурок. Если введённый символ равен ‘q’, то происходит выход из программы.

# Функциональное проектирование
Основной процедурой в программе является процедура SHIFT_FIGURE. Она выполняет смещение текущей точки фигурки, значение которой хранится в переменной cp. При вызове она использует значение регистра al, который определяет, в какую сторону сместить фигурку или вызвать процедуру переворота.
Функция SHIFT_POSSIBLE определяет максимальный диапазон смещения фигурки в линии. Левую границу диапазона помещает в регистр dh, правую в регистр dl и нижнюю – в ch.
Процедура ROT_FIGURE осуществляет переворот фигурки, используя массивы fr и to.
Функция PUT_FIGURE используется для размещения фигурки в стакане, стирание её, а также для проверки свободных ячеек для квадратиков фигурки. Характер её работы определяется регистром cl. Если свободных ячеек нет, функция возвращает в регистре bx нуль.
Функция ROT_POSSIBLE проверяет возможность переворота фигурки возле границы стакана. Если переворот невозможен, то функция возвращает в регистре bx нуль.
Функция CLEAR_LINE производит поиск полностью заполненных линий, удаление их и смещение вниз содержимого стакана, которое находится выше удалённых линий. Также эта функция изменяет значения переменных score, lines и level.
Функция NEXT_FIGURE с помощью алгоритма генерации псевдослучайных чисел определяет следующую фигурку и заносит её адрес в переменную fig, заносит в переменную cp начальное значение текущей точки. Если нет места для размещения новой фигурки, то функция производит выход из программы.
Процедура PRINT_MAP перебирает ячейки матрицы стакана и для каждой вызывает процедуру прорисовки квадратика на экране.
Процедура PRINT_BLOCK, используя адрес квадратика, полученный из предыдущей процедуры, вычислят его местоположения на экране и, прямым копированием байтом цвета в видеопамять, рисует псевдообъёмные квадратики заданного цвета.
Процедура PRINT_GLASS рисует на экране границы стакана цветом, который хранится в переменной gc.
Процедуры PRINT_HEAD, PAUSE_PRINT, FRAME_PRINT, PRINT_SCORE, PRINT_LINES, PRINT_LEVEL, PRINT_ROT, PRINT_LEFT, PRINT_RIGHT, PRINT_DOWN, PRINT_P, PRINT_QUIT, PRINT_GO используются для отображения текста на экране с помощью процедуры OUTPUT_TEXT, которая посимвольно выводит текст, полученный из вышеуказанных процедур в регистре bx.
Процедура OUTPUT_NUM производит отображение числа, которое находится в регистре ax на экран, начиная с младших разрядов, посредством деления его на 10.

# Разработка программных модулей

Процедура SHIFT_FIGURE
	
При вызове процедура получает в регистре al код символа для смещения фигурки. Вызывает функцию определения диапазона смещения SHIFT_POSSIBLE.
Если была нажата клавиша «», то вызывается процедура переворота фигурки ROT_FIGURE.
Если нажата клавиша «», то выполняются команды для смещения влево. Значение текущей точки делится на 10, в результате в регистр ah помещается номер столбца текущей точки. В ah добавляется dh и сумма сравнивается с нулём. Если равно – выход из процедуры. Иначе происходит стирание фигурки с помощью функции PUT_FIGURE и регистра cl=0. Текущая точка уменьшается на единицу и проверяется на свободные ячейки функцией PUT_FIGURE с регистром cl=255. В стеке сохраняется регистр bx и регистру cl присваивается цвет текущей фигурки посредством команд mov bx, fig и mov cl, [bx+4]. Из стека восстанавливается bx и сравнивается с нулём. Если равно, то увеличивается значение текущей точки и фигурка рисуется на прежнее место. Иначе фигурка рисуется с новой текущей точки. Выход из процедуры.
Если была нажата клавиша «», то выполняются команды для смещения вправо. Значение текущей точки делится на 10, в результате в регистр ah помещается номер столбца текущей точки. В ah добавляется dl и сумма сравнивается с девяткой. Если равно – выход из процедуры. Иначе происходит стирание фигурки с помощью функции PUT_FIGURE и регистра cl=0. Текущая точка увеличивается на единицу и проверяется на свободные ячейки функцией PUT_FIGURE с регистром cl=255. В стеке сохраняется регистр bx и регистру cl присваивается цвет текущей фигурки посредством команд mov bx, fig и mov cl, [bx+4]. Из стека восстанавливается bx и сравнивается с нулём. Если равно, то уменьшается значение текущей точки и фигурка рисуется на прежнее место. Иначе фигурка рисуется с новой текущей точки. Выход из процедуры.
Если была нажата клавиша «», то выполняются команды для смещения вниз. Размер фигурки снизу, который находится в регистре ch после выполнения функции SHIFT_POSSIBLE, умножается на 10. Произведение складывается с текущей точкой, и, если сумма больше или равно 170, то вызываются функции CLEAR_LINE и NEXT_FIGURE. Иначе фигурка стирается, к текущей точке добавляется 10 и проверяется на свободные ячейки. В стеке сохраняется регистр bx и регистру cl присваивается цвет текущей фигурки посредством команд mov bx, fig и mov cl, [bx+4]. Из стека восстанавливается bx и сравнивается с нулём. Если равно, то уменьшается значение текущей точки на 10 и фигурка рисуется на прежнее место. Иначе фигурка рисуется с новой текущей точки. Выход из процедуры.

Функция PUT_FIGURE

При вызове функция получает в качестве параметра регистр cl, в котором находится цвет, назначаемый ячейке. Регистру di присваивается значение текущей точки, очищается регистр si.
Цикл функции начинается с очищения регистра ax и занесения в bx адреса текущей фигурки. В al заносится si-тый элемент координат описания текучей фигурки. Регистр si является счётчиком цикла. Регистр ax смещается на 8 бит влево, а затем на 4 бита вправо с учётом знака. В bx заносится адрес матрицы стакана, прибавляется к нему значение текущей точки и значение регистра ah, в котором находится координата X-смещения квадратика фигурки относительно текущей точки. Очищается регистр ah, и регистр al смещается вправо с учётом знака, и умножается на 10, и прибавляется к bl. Регистр cl сравнивается с 255, и, если равно, то сравнивает значение ячейки по адресу bx с нулём. Если не равно, то происходит выход из функции с bx=0.
Если же cl не равен 255, то ячейке по адресу bx присваивается значение cl. После этого увеличивается si на единицу и сравнивается с четвёркой. Если не равно, то цикл повторяется. Иначе вызывается процедура вывода на экран содержимого всего стакана. Выход из функции происходит с bx0.
